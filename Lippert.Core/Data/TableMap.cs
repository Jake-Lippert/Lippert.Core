using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text.RegularExpressions;
using Lippert.Core.Collections.Extensions;
using Lippert.Core.Data.Contracts;
using Lippert.Core.Reflection;

namespace Lippert.Core.Data
{
	public abstract class TableMap<T> : ITableMap<T>
	{
		private static readonly Regex _validName = new Regex(@"^[A-Za-z][A-Za-z_0-9]*$");
		private readonly Dictionary<PropertyInfo, int> _propertyOrder;

		/// <summary>
		/// Constructs a TableMap instance for the current table
		/// </summary>
		public TableMap()
		{
			Table(typeof(T).Name);
			//--Keep track of what properties' orders are within the class, as TableMapBuilders aren't applied in any specific order
			_propertyOrder = typeof(T).GetProperties(BindingFlags.Instance | BindingFlags.GetProperty | BindingFlags.Public | BindingFlags.NonPublic)
				.Indexed()
				.ToDictionary(x => x.item, x => x.index);
			TypeColumns = new ReadOnlyDictionary<Type, Dictionary<PropertyInfo, IColumnMap>>(GetTypes(typeof(T)).Distinct()
				.ToDictionary(t => t, t => new Dictionary<PropertyInfo, IColumnMap>()));

			foreach (var mapBuilder in TableMapSource.GetTableMapBuilders<T>())
			{
				//--I really hate having to do this...
				mapBuilder.GetType()
					.GetMethod(nameof(TableMapBuilder<object>.Map))
					.MakeGenericMethod(typeof(T))
					.Invoke(mapBuilder, new[] { this });
			}

			List<Type> GetTypes(Type type)
			{
				var types = new List<Type>();
				if (type != typeof(object))
				{
					types.Add(type);
					types.AddRange(GetTypes(type.BaseType));
					types.AddRange(type.GetInterfaces());
				}

				return types;
			}
		}

		/// <summary>
		/// Gets the model type for the table being mapped
		/// </summary>
		Type ITableMap.GetModelType() => typeof(T);

		/// <summary>
		/// Gets the name of the table that is being mapped
		/// </summary>
		public string TableName { get; private set; }

		/// <summary>
		/// Sets the name of the table that is being mapped
		/// </summary>
		public void Table(string name)
		{
			if (!_validName.IsMatch(name ?? throw new ArgumentNullException(nameof(name))))
			{
				throw new ArgumentException($"The table name '{name}' is not valid.", nameof(name));
			}

			TableName = name;
		}

		/// <summary>
		/// Gets a dictionaries of column mappings with respect to their declaring type
		/// </summary>
		public ReadOnlyDictionary<Type, Dictionary<PropertyInfo, IColumnMap>> TypeColumns { get; }

		/// <summary>
		/// Gets the columns that are mapped for the current table type
		/// </summary>
		private Dictionary<PropertyInfo, IColumnMap> InstanceColumns => TypeColumns[typeof(T)];

		/// <summary>
		/// Gets the columns that are available for insert operations
		/// </summary>
		public List<IColumnMap> InsertColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(IgnoreBehavior.Insert));

		/// <summary>
		/// Gets the columns that are available for update operations
		/// </summary>
		public List<IColumnMap> UpdateColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(IgnoreBehavior.Update));

		/// <summary>
		/// Gets the columns that are available for select operations
		/// </summary>
		public List<IColumnMap> SelectColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(IgnoreBehavior.Select));

		/// <summary>
		/// Gets the columns that are generated by the database upon insert
		/// </summary>
		public List<IColumnMap> GeneratedColumns => GetColumns(c => c.Behavior.HasFlag(ColumnBehavior.Generated) ||
			(c.IgnoreOperations.HasFlag(IgnoreBehavior.Insert) && !c.IgnoreOperations.HasFlag(IgnoreBehavior.Select)));

		/// <summary>
		/// Gets the columns that are keys for the table
		/// </summary>
		public List<IColumnMap> KeyColumns => GetColumns(c => c.Behavior.HasFlag(ColumnBehavior.Key));

		/// <summary>
		/// Gets a table's instance columns in the same order as Type.GetProperties()
		/// </summary>
		private List<IColumnMap> GetColumns(Func<IColumnMap, bool> predicate) => InstanceColumns.OrderBy(x => _propertyOrder.TryGetValue(x.Key, out var order) ? order : int.MaxValue)
			.Select(x => x.Value)
			.Where(predicate)
			.ToList();

		/// <summary>
		/// Maps a column for the property with respect to the table map's class
		/// </summary>
		public IColumnMap Map(Expression<Func<T, object>> column) =>
			Map(new ColumnMap<T>(column ?? throw new ArgumentNullException(nameof(column))));

		/// <summary>
		/// Maps a column for the property with respect to the table map's class
		/// </summary>
		public IColumnMap Map(IColumnMap columnMap)
		{
			//--Iterate through each class, subclass, and interface
			foreach (var (type, columns) in TypeColumns.AsTuples())
			{
				if (type.IsInterface ^ columnMap.Property.DeclaringType.IsInterface)
				{
					//--Map a class's or interface's property to the loop's current interface or class
					if (PropertyAccessor.Get(columnMap.Property, type) is PropertyInfo targetProperty)
					{
						TypeColumns[type].Add(targetProperty, columnMap);
					}
				}
				else if (columnMap.Property.DeclaringType.IsAssignableFrom(type))
				{
					TypeColumns[type].Add(columnMap.Property, columnMap);
				}
			}

			return columnMap;
		}

		/// <summary>
		/// Gets the column map for the property with respect to the table map's class
		/// </summary>
		public IColumnMap this[Expression<Func<T, object>> column] => this[PropertyAccessor.Get(column ?? throw new ArgumentNullException(nameof(column)))];

		/// <summary>
		/// Gets the column map for the property that applies to the table map's class, a subclass, or an interface
		/// </summary>
		public IColumnMap this[PropertyInfo property] => TypeColumns[(property ?? throw new ArgumentNullException(nameof(property))).DeclaringType][property];


		/// <summary>
		/// Maps unmapped properties as basic columns
		/// </summary>
		public void AutoMap() => AutoMap(map => { });

		/// <summary>
		/// Maps the specified properties as basic columns
		/// </summary>
		public void AutoMap(params Expression<Func<T, object>>[] includedColumns)
		{
			foreach (var includedColumn in includedColumns)
			{
				Map(includedColumn);
			}
		}

		/// <summary>
		/// Maps unmapped properties as specified
		/// </summary>
		public void AutoMap(Action<IColumnMap> configureColumn)
		{
			foreach (var property in typeof(T).GetProperties().Except(InstanceColumns.Select(c => c.Key)))
			{
				configureColumn(Map(new ColumnMap<T>(property)));
			}
		}
	}
}