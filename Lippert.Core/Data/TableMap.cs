using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text.RegularExpressions;
using Lippert.Core.Collections.Extensions;
using Lippert.Core.Data.Contracts;
using Lippert.Core.Reflection;
using Lippert.Core.Reflection.Extensions;

namespace Lippert.Core.Data
{
	public abstract class TableMap<T> : ITableMap<T>
	{
		private static readonly Regex _validName = new Regex(@"^[A-Za-z][A-Za-z_0-9]*$");
		private readonly Dictionary<PropertyInfo, int> _propertyOrder;
		private readonly Dictionary<PropertyInfo, IColumnMap> _columnMaps = new Dictionary<PropertyInfo, IColumnMap>();
		private readonly Type _includePropertiesAssignableTo;

		/// <summary>
		/// Constructs a TableMap instance for the current table, including no inherited columns
		/// </summary>
		public TableMap()
			: this(typeof(T)) { }
		/// <summary>
		/// Constructs a TableMap instance for the current table, including inherited columns down to the specified class
		/// </summary>
		/// <param name="includePropertiesAssignableTo">The lowest class that properties should be included from</param>
		public TableMap(Type includePropertiesAssignableTo)
		{
			Table(TableName = ModelType.Name);//--'TableName = ' is a slight hack to get the compiler to stop yelling about it not being set, even though Table(...) would have set it or thrown an exception

			if (includePropertiesAssignableTo.IsInterface || !includePropertiesAssignableTo.IsAssignableFrom(ModelType))
			{
				throw new ArgumentException($"The type '{includePropertiesAssignableTo.FullName}' is not a subclass of '{ModelType.FullName}'.");
			}
			_includePropertiesAssignableTo = includePropertiesAssignableTo;
			//--Keep track of what properties' orders are within the class, as TableMapBuilders aren't applied in any specific order
			_propertyOrder = ModelType.GetProperties(BindingFlags.Instance | BindingFlags.GetProperty | BindingFlags.Public | BindingFlags.NonPublic)
				.Indexed()
				.ToDictionary(x => x.item, x => x.index);
			TypeColumns = new ReadOnlyDictionary<Type, Dictionary<PropertyInfo, IColumnMap>>(ModelType.GetBaseTypes(includeSeed: true, includeInterfaces: true).Distinct()
				.ToDictionary(t => t, t => new Dictionary<PropertyInfo, IColumnMap>()));

			foreach (var mapBuilder in TableMapSource.GetTableMapBuilders<T>())
			{
				//--I really hate having to do this...
				mapBuilder.GetType()
					.GetMethod(nameof(TableMapBuilder<object>.Map))
					.MakeGenericMethod(ModelType)
					.Invoke(mapBuilder, new[] { this });
			}
		}

		/// <summary>
		/// Gets the model type for the table being mapped
		/// </summary>
		public Type ModelType { get; } = typeof(T);

		/// <summary>
		/// Gets the name of the table that is being mapped
		/// </summary>
		public string TableName { get; private set; }

		/// <summary>
		/// Sets the name of the table that is being mapped
		/// </summary>
		public void Table(string name)
		{
			if (!_validName.IsMatch(name ?? throw new ArgumentNullException(nameof(name))))
			{
				throw new ArgumentException($"The table name '{name}' is not valid.", nameof(name));
			}

			TableName = name;
		}

		/// <summary>
		/// Gets dictionaries of column mappings with respect to their declaring type
		/// </summary>
		public ReadOnlyDictionary<Type, Dictionary<PropertyInfo, IColumnMap>> TypeColumns { get; }

		/// <summary>
		/// Gets the columns that are mapped for the current table type
		/// </summary>
		public Dictionary<PropertyInfo, IColumnMap> InstanceColumns => TypeColumns[typeof(T)];

		/// <summary>
		/// Gets the columns that are available for insert operations
		/// </summary>
		public List<IColumnMap> InsertColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(SqlOperation.Insert));

		/// <summary>
		/// Gets the columns that are available for insert or update operations
		/// </summary>
		public List<IColumnMap> UpsertColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(SqlOperation.Insert | SqlOperation.Update));

		/// <summary>
		/// Gets the columns that are available for update operations
		/// </summary>
		public List<IColumnMap> UpdateColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(SqlOperation.Update));

		/// <summary>
		/// Gets the columns that are available for select operations
		/// </summary>
		public List<IColumnMap> SelectColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(SqlOperation.Select));

		/// <summary>
		/// Gets the columns that are generated by the database upon insert
		/// </summary>
		public List<IColumnMap> GeneratedColumns => GetColumns(c => c.Behavior.HasFlag(ColumnBehavior.Generated) ||
			(c.IgnoreOperations.HasFlag(SqlOperation.Insert) && !c.IgnoreOperations.HasFlag(SqlOperation.Select)));

		/// <summary>
		/// Gets the columns that are keys for the table
		/// </summary>
		public List<IColumnMap> KeyColumns => GetColumns(c => c.Behavior.HasFlag(ColumnBehavior.Key));

		/// <summary>
		/// Gets a table's instance columns in the same order as Type.GetProperties()
		/// </summary>
		private List<IColumnMap> GetColumns(Func<IColumnMap, bool> predicate) => InstanceColumns.OrderBy(x => _propertyOrder.TryGetValue(x.Key, out var order) ? order : int.MaxValue)
			.Select(x => x.Value)
			.Where(predicate)
			.ToList();

		/// <summary>
		/// Maps a column for the property with respect to the table map's class
		/// </summary>
		public IColumnMap Map(Expression<Func<T, object?>> column) => Map(new ColumnMap<T>(column ?? throw new ArgumentNullException(nameof(column))));

		/// <summary>
		/// Maps a column for the property with respect to the table map's class
		/// </summary>
		private IColumnMap Map(IColumnMap columnMap)
		{
			//--Check for an existing map for the specified column.
			var (declaringType, declaringProperty) = columnMap.Property.GetDeclaringType(getInterface: true);
			if (!_columnMaps.TryGetValue(declaringProperty, out columnMap))
			{
				//--Always build for the most-common class/interface
				_columnMaps[declaringProperty] = columnMap = new ColumnMap<T>(declaringProperty);
			}

			//--Iterate through each class, subclass, and interface
			foreach (var (type, columns) in TypeColumns.Where(tc => declaringType.IsAssignableFrom(tc.Key)).AsTuples())
			{
				PropertyInfo targetProperty;
				if (type.IsInterface == declaringType.IsInterface)
				{
					targetProperty = declaringProperty;
				}
				//--Map a class's or interface's property to the loop's current interface or class
				else if (declaringProperty.TryGet(type, out var mappedProperty))
				{
					targetProperty = mappedProperty!;
				}
				else
				{
					continue;
				}

				if (_includePropertiesAssignableTo.IsAssignableFrom(targetProperty.DeclaringType) ||
					declaringProperty.TryGet(ModelType, out var typeProperty) &&
						_includePropertiesAssignableTo.IsAssignableFrom(typeProperty!.DeclaringType))
				{
					columns[targetProperty] = columnMap;
				}
			}

			return columnMap;
		}

		/// <summary>
		/// Gets the column map for the property with respect to the table map's class
		/// </summary>
		public IColumnMap this[Expression<Func<T, object?>> column] => this[PropertyAccessor.Get(column ?? throw new ArgumentNullException(nameof(column)))];

		/// <summary>
		/// Gets the column map for the property that applies to the table map's class, a subclass, or an interface
		/// </summary>
		public IColumnMap this[PropertyInfo property] => TypeColumns[(property ?? throw new ArgumentNullException(nameof(property))).DeclaringType][property];


		/// <summary>
		/// Maps unmapped properties as basic columns
		/// </summary>
		public void AutoMap() => AutoMap((type, map) => { });

		/// <summary>
		/// Maps the specified properties as basic columns
		/// </summary>
		public void AutoMap(params Expression<Func<T, object?>>[] includedColumns)
		{
			foreach (var includedColumn in includedColumns)
			{
				Map(includedColumn);
			}
		}

		/// <summary>
		/// Maps unmapped properties as specified
		/// </summary>
		public void AutoMap(Action<Type, IColumnMap> configureColumn)
		{
			foreach (var property in ModelType.GetProperties().Except(InstanceColumns.Select(c => c.Key)))
			{
				configureColumn(ModelType, Map(new ColumnMap<T>(property)));
			}
		}
	}
}