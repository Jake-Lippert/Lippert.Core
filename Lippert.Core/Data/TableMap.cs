using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text.RegularExpressions;
using Lippert.Core.Collections.Extensions;
using Lippert.Core.Data.Contracts;
using Lippert.Core.Reflection;

namespace Lippert.Core.Data
{
	public abstract class TableMap<T> : ITableMap<T>
	{
		private static readonly Regex _validName = new Regex(@"^[A-Za-z][A-Za-z_0-9]*$");
		private readonly Dictionary<PropertyInfo, int> _propertyOrder;
		private readonly Type _includePropertiesAssignableTo;

		/// <summary>
		/// Constructs a TableMap instance for the current table, including no inherited columns
		/// </summary>
		public TableMap()
			: this(typeof(T)) { }
		/// <summary>
		/// Constructs a TableMap instance for the current table, including inherited columns down to the specified class
		/// </summary>
		/// <param name="includePropertiesAssignableTo">The lowest class that properties should be included from</param>
		public TableMap(Type includePropertiesAssignableTo)
		{
			Table(ModelType.Name);

			if (includePropertiesAssignableTo.IsInterface || !includePropertiesAssignableTo.IsAssignableFrom(ModelType))
			{
				throw new ArgumentException($"The type '{includePropertiesAssignableTo.FullName}' is not a subclass of '{ModelType.FullName}'.");
			}
			_includePropertiesAssignableTo = includePropertiesAssignableTo;
			//--Keep track of what properties' orders are within the class, as TableMapBuilders aren't applied in any specific order
			_propertyOrder = ModelType.GetProperties(BindingFlags.Instance | BindingFlags.GetProperty | BindingFlags.Public | BindingFlags.NonPublic)
				.Indexed()
				.ToDictionary(x => x.item, x => x.index);
			TypeColumns = new ReadOnlyDictionary<Type, Dictionary<PropertyInfo, IColumnMap>>(GetTypes(ModelType).Distinct()
				.ToDictionary(t => t, t => new Dictionary<PropertyInfo, IColumnMap>()));

			foreach (var mapBuilder in TableMapSource.GetTableMapBuilders<T>())
			{
				//--I really hate having to do this...
				mapBuilder.GetType()
					.GetMethod(nameof(TableMapBuilder<object>.Map))
					.MakeGenericMethod(ModelType)
					.Invoke(mapBuilder, new[] { this });
			}

			List<Type> GetTypes(Type type)
			{
				var types = new List<Type>();
				if (type != typeof(object))
				{
					types.Add(type);
					types.AddRange(GetTypes(type.BaseType));
					types.AddRange(type.GetInterfaces());
				}

				return types;
			}
		}

		/// <summary>
		/// Gets the model type for the table being mapped
		/// </summary>
		public Type ModelType { get; } = typeof(T);

		/// <summary>
		/// Gets the name of the table that is being mapped
		/// </summary>
		public string TableName { get; private set; }

		/// <summary>
		/// Sets the name of the table that is being mapped
		/// </summary>
		public void Table(string name)
		{
			if (!_validName.IsMatch(name ?? throw new ArgumentNullException(nameof(name))))
			{
				throw new ArgumentException($"The table name '{name}' is not valid.", nameof(name));
			}

			TableName = name;
		}

		/// <summary>
		/// Gets a dictionaries of column mappings with respect to their declaring type
		/// </summary>
		public ReadOnlyDictionary<Type, Dictionary<PropertyInfo, IColumnMap>> TypeColumns { get; }

		/// <summary>
		/// Gets the columns that are mapped for the current table type
		/// </summary>
		public Dictionary<PropertyInfo, IColumnMap> InstanceColumns => TypeColumns[typeof(T)];

		/// <summary>
		/// Gets the columns that are available for insert operations
		/// </summary>
		public List<IColumnMap> InsertColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(SqlOperation.Insert));

		/// <summary>
		/// Gets the columns that are available for update operations
		/// </summary>
		public List<IColumnMap> UpdateColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(SqlOperation.Update));

		/// <summary>
		/// Gets the columns that are available for select operations
		/// </summary>
		public List<IColumnMap> SelectColumns => GetColumns(c => !c.IgnoreOperations.HasFlag(SqlOperation.Select));

		/// <summary>
		/// Gets the columns that are generated by the database upon insert
		/// </summary>
		public List<IColumnMap> GeneratedColumns => GetColumns(c => c.Behavior.HasFlag(ColumnBehavior.Generated) ||
			(c.IgnoreOperations.HasFlag(SqlOperation.Insert) && !c.IgnoreOperations.HasFlag(SqlOperation.Select)));

		/// <summary>
		/// Gets the columns that are keys for the table
		/// </summary>
		public List<IColumnMap> KeyColumns => GetColumns(c => c.Behavior.HasFlag(ColumnBehavior.Key));

		/// <summary>
		/// Gets a table's instance columns in the same order as Type.GetProperties()
		/// </summary>
		private List<IColumnMap> GetColumns(Func<IColumnMap, bool> predicate) => InstanceColumns.OrderBy(x => _propertyOrder.TryGetValue(x.Key, out var order) ? order : int.MaxValue)
			.Select(x => x.Value)
			.Where(predicate)
			.ToList();

		/// <summary>
		/// Maps a column for the property with respect to the table map's class
		/// </summary>
		public IColumnMap Map(Expression<Func<T, object>> column) =>
			Map(new ColumnMap<T>(column ?? throw new ArgumentNullException(nameof(column))));

		/// <summary>
		/// Maps a column for the property with respect to the table map's class
		/// </summary>
		public IColumnMap Map(IColumnMap columnMap)
		{
			//--Iterate through each class, subclass, and interface
			foreach (var (type, columns) in TypeColumns.AsTuples())
			{
				if (columnMap.Property.DeclaringType.IsAssignableFrom(type))
				{
					if (type.IsInterface ^ columnMap.Property.DeclaringType.IsInterface)
					{
						//--Map a class's or interface's property to the loop's current interface or class
						if (PropertyAccessor.Get(columnMap.Property, type) is PropertyInfo targetProperty)
						{
							AddProperty(targetProperty);
						}
					}
					else
					{
						AddProperty(columnMap.Property);
					}
				}

				void AddProperty(PropertyInfo property)
				{
					if (_includePropertiesAssignableTo.IsAssignableFrom(property.DeclaringType))
					{
						TypeColumns[type].Add(property, columnMap);
					}
					else
					{
						try
						{
							if (PropertyAccessor.Get(columnMap.Property, ModelType) is PropertyInfo typeProperty &&
								_includePropertiesAssignableTo.IsAssignableFrom(typeProperty.DeclaringType))
							{
								TypeColumns[type].Add(property, columnMap);
							}
						}
						catch { }
					}
				}
			}

			return columnMap;
		}

		/// <summary>
		/// Gets the column map for the property with respect to the table map's class
		/// </summary>
		public IColumnMap this[Expression<Func<T, object>> column] => this[PropertyAccessor.Get(column ?? throw new ArgumentNullException(nameof(column)))];

		/// <summary>
		/// Gets the column map for the property that applies to the table map's class, a subclass, or an interface
		/// </summary>
		public IColumnMap this[PropertyInfo property] => TypeColumns[(property ?? throw new ArgumentNullException(nameof(property))).DeclaringType][property];


		/// <summary>
		/// Maps unmapped properties as basic columns
		/// </summary>
		public void AutoMap() => AutoMap((type, map) => { });

		/// <summary>
		/// Maps the specified properties as basic columns
		/// </summary>
		public void AutoMap(params Expression<Func<T, object>>[] includedColumns)
		{
			foreach (var includedColumn in includedColumns)
			{
				Map(includedColumn);
			}
		}

		/// <summary>
		/// Maps unmapped properties as specified
		/// </summary>
		public void AutoMap(Action<Type, IColumnMap> configureColumn)
		{
			foreach (var property in ModelType.GetProperties().Except(InstanceColumns.Select(c => c.Key)))
			{
				configureColumn(ModelType, Map(new ColumnMap<T>(property)));
			}
		}
	}
}